{"ast":null,"code":"import _defineProperty from \"/workspace/crown-clothing/crown-clothing/v3_CART/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Utility functions allow us to keep our files clean and organize functions that we may need in\n// multiple files in one location\n// Function that takes two arguments, 1. all the existing items that are in our cartItems array\n// right now, 2. the cart item that we want to add\nexport const addItemToCart = (cartItems, cartItemToAdd) => {\n  // First we look inside cartItems to see if the cart item already exists in the array\n  // If the id is matching an existing id, it will set that cart item to our constant, if not, it will\n  // be undefined\n  const existingCartItem = cartItems.find(cartItem => cartItem.id == cartItemToAdd.id); // If it matches cartItem.map wil return us a new array, because we need to return new versions of\n  // our state so that our components know to rerender properly.\n  // This if statement won't run when there is a new item\n\n  if (existingCartItem) {\n    // We want to pass each cart item inside our map and create a new object if the id's match, where\n    // we have the cartItem and increase the quantity by one, and if they don't match, we just return\n    // the original cart item\n    return cartItems.map(cartItem => cartItem.id == cartItemToAdd.id ? _objectSpread({}, cartItem, {\n      quantity: cartItem.quantity + 1\n    }) : cartItem);\n  } // If the cart item is not found in the array, we want to return a new array with all the existing\n  // cart items and add an object which is equal to our cartItemToAdd and give it a base quantity of 1\n\n\n  return [...cartItems, _objectSpread({}, cartItemToAdd, {\n    quantity: 1\n  })];\n};","map":{"version":3,"sources":["/workspace/crown-clothing/crown-clothing/v3_CART/src/redux/cart/cart.utils.js"],"names":["addItemToCart","cartItems","cartItemToAdd","existingCartItem","find","cartItem","id","map","quantity"],"mappings":";;;;;;AAAA;AACA;AAEA;AACA;AACA,OAAO,MAAMA,aAAa,GAAG,CAACC,SAAD,EAAYC,aAAZ,KAA8B;AAC1D;AACA;AACA;AACA,QAAMC,gBAAgB,GAAGF,SAAS,CAACG,IAAV,CAAeC,QAAQ,IAAIA,QAAQ,CAACC,EAAT,IAAeJ,aAAa,CAACI,EAAxD,CAAzB,CAJ0D,CAM1D;AACA;AACA;;AACA,MAAIH,gBAAJ,EAAsB;AACrB;AACA;AACA;AACA,WAAOF,SAAS,CAACM,GAAV,CAAcF,QAAQ,IAC5BA,QAAQ,CAACC,EAAT,IAAeJ,aAAa,CAACI,EAA7B,qBACQD,QADR;AACkBG,MAAAA,QAAQ,EAAEH,QAAQ,CAACG,QAAT,GAAoB;AADhD,SAEGH,QAHG,CAAP;AAKA,GAlByD,CAoB1D;AACA;;;AACA,SAAO,CAAC,GAAGJ,SAAJ,oBAAoBC,aAApB;AAAmCM,IAAAA,QAAQ,EAAE;AAA7C,KAAP;AACA,CAvBM","sourcesContent":["// Utility functions allow us to keep our files clean and organize functions that we may need in\n// multiple files in one location\n\n// Function that takes two arguments, 1. all the existing items that are in our cartItems array\n// right now, 2. the cart item that we want to add\nexport const addItemToCart = (cartItems, cartItemToAdd) => {\n\t// First we look inside cartItems to see if the cart item already exists in the array\n\t// If the id is matching an existing id, it will set that cart item to our constant, if not, it will\n\t// be undefined\n\tconst existingCartItem = cartItems.find(cartItem => cartItem.id == cartItemToAdd.id);\n\t\n\t// If it matches cartItem.map wil return us a new array, because we need to return new versions of\n\t// our state so that our components know to rerender properly.\n\t// This if statement won't run when there is a new item\n\tif (existingCartItem) {\n\t\t// We want to pass each cart item inside our map and create a new object if the id's match, where\n\t\t// we have the cartItem and increase the quantity by one, and if they don't match, we just return\n\t\t// the original cart item\n\t\treturn cartItems.map(cartItem => \n\t\t\tcartItem.id == cartItemToAdd.id \n\t\t\t\t? { ...cartItem, quantity: cartItem.quantity + 1 }\n\t\t\t\t: cartItem\n\t\t)\n\t}\n\t\n\t// If the cart item is not found in the array, we want to return a new array with all the existing\n\t// cart items and add an object which is equal to our cartItemToAdd and give it a base quantity of 1\n\treturn [...cartItems, { ...cartItemToAdd, quantity: 1 }]\n};"]},"metadata":{},"sourceType":"module"}